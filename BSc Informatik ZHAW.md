- BSc Informatik ZHAW

# 1. Semester

# Software-Projekt 1

- Umsetzen der Lehrinhalte von "Programmieren 1"
- Teamarbeit
  - Selbstreflexion
  - Kommunikation technischer Inhalte
  - Codemanagement

# Programmieren 1

- Konzepte der objektorientierten Programmierung
  - Klassen
  - Objekte etc.

- Grundlagen der Programmierung
  - Datentypen
  - Kontrollstrukturen etc.

- grundlegende Praktiken
  - Clean Code
  - Software Qualitätssicherung
    - Dokumentation
    - Unit-Test

- grundlegende OOP-Prinzipien
  - Vererbung
  - Komposition
  - Polymorphie

# Datenbanken

- relationale Algebra
- Entity-Relationship-Design
- SQL DDL/DML
- effiziente und korrekte Datenbankabfragen in SQL
- Indexe
- Trigger
- Transaktionen/ACID

# Information und Codierung

- Digitale Informationsverarbeitung & Codierung
  - Algorithmus-Begriff
  - Euklidischer Algorithmus
  - Digitale Grundeinheiten
    - Bit
    - Byte
    - Wort
  - Komplement-Darstellung
    - Einer- und Zweierkomplement
  - Rechnen im Zahlenkreis
    - Carry
    - Borrow
    - Overflow
    - Sign Extension
- Digitaltechnik
  - Logische Funktionen und Gatter
    - INV
    - AND
    - OR
    - NAND
    - NOR
    - XOR
  - Wahrheitstabellen und kombinatorische Schaltungen
    - Halb-/Voll-Addierer
    - Subtrahierer
    - Dekoder (z.B. BCD → 7-Segment)
    - Komparator
    - Codeumwandlungen
  - Sequentielle Logik
    - Zähler
    - Schieberegister
    - einfacher Automat (z.B. Ampel)
- Informationstheorie
  - Grundlagen nach Shannon
  - Entropie
  - Informationsgehalt
  - Redundanz
  - Berechnung der Entropie
- Quellencodierung
  - Redundanz- und Irrelevanzreduktion
  - Präfixfreiheit
  - Huffman
  - Arithmetische Codierung
  - Lauflängencodierung
  - Lempel-Ziv
  - Überblick JPEG
  - MPEG (nur Ansätze)
  - Einsatzgebiete der Codierungen
- Kanalcodierung
  - Kanalkapazität nach Shannon
  - Hamming-Distanz
  - Fehlererkennung
    - Parität
    - CRC
    - Checksumme
  - Fehlerkorrektur
    - Hamming-Code
    - Block-Code
    - Faltungscode (Überblick)

# Grundlagen der Elektrotechnik und Digitaltechnik

- Grundbegriffe
  - Ladung
  - Kraft
  - Energie
  - Leistung
  - Spannung
- Strom und Widerstand
  - Widerstand
  - Strom
  - Ohmsches Gesetz
- Schaltungen
  - Kirchhoffsche Gesetze
  - Reihen- und Parallelschaltungen
- Reaktive Bauteile
  - Induktivität
  - Kapazität
  - Ein- und Ausschaltverhalten
- Signalformen
  - Zeit- und Frequenzraum
  - Amplitude
  - Frequenz
  - Bandbreite
  - Fourier-Transformation
  - Spektrum
- Filter
  - Hochpass
  - Tiefpass
  - Bezug zur Informatik
- Halbleitertechnik
- Dioden, Transistoren
  - Funktionsweise
  - Push-Pull und Open-Drain Outputs
- Digitaltechnik
  - Logikgatter
  - Logikfamilien
  - Zusammenschaltung zu D-Flipflop
  - Zusammenhang Boolsche Algebra
- Felder & Wellen
- Elektrische und magnetische Felder
- Elektromagnetische Wellen
  - Frequenz
  - Wellenlänge
  - Ausbreitungsgeschwindigkeit
- Wechselwirkung mit Medium
  - Brechung
  - Reflexion
  - Dispersion
  - Absorption (z. B. Glasfaser)
  - Dämpfung
  - SNR

# Analysis 1

- Konzepte der Differential- und Integralrechnung
  - Ableitung
  - Stammfunktionen und Flächeninhalte bei Polynomen
- Folgen
- Reihen (mit Summen) und Grenzwerte
  - Folgen
    - direkt
    - rekursiv
    - arithmetisch/geometrisch
  - Grenzwertbegriff
    - Rechenregeln
    - Limes einer Funktion
  - Stetigkeit
  - Reihen (arithmetisch/geometrisch)
- Erweiterung der Differentialrechnung
  - Ableitung elementarer Funktionen
  - Ableitungsregeln
  - Kurvendiskussion
  - Gebrochen rationale Funktionen
    - Polstellen
    - hebbare Definitionslücken
    - Asymptoten
  - Extremwertaufgaben
  - Newton-Verfahren

# Diskrete Mathematik

- Grundbegriffe
  - Zahlenmengen
  - Aussagen
  - Prädikate
  - Quantoren
- Mengenlehre
  - Elemente
  - Teilmengen
  - Extensionalität
  - Aussonderungsprinzip
  - Ersetzungsprinzip
- Mengenoperationen
  - Potenzmenge
  - Schnittmenge
  - Vereinigungsmenge
  - Differenzmenge
  - Komplement
- Mächtigkeit
  - Abzählbarkeit
  - Überabzählbarkeit
  - Erstes Diagonalargument
  - Zweites Diagonalargument
- Relationen
  - Tupel
  - Produktmengen
  - Funktionen als Relationen
  - Äquivalenzrelationen
    - Äquivalenzklassen
    - Partitionen
    - Reflexivität
    - Symmetrie
    - Transitivität
  - Ordnungsrelationen
    - Halbordnungen
    - Totalordnungen
    - Hasse-Diagramme
    - Satz von Marczewski-Szpilrajn
- Rekursive Strukturen
  - Natürliche Zahlen
  - Peano-Axiome
  - Vollständige Induktion
  - Wohlfundierte Induktion
  - Induktive Definitionen
    - Strukturelle Induktion
    - Rekursive Definitionen
    - Rekursionsgleichungen
- Elementare Zahlentheorie
  - Teilbarkeit
  - Euklidischer Algorithmus
  - Primzahlen
  - Primfaktorzerlegung
  - Eindeutigkeit der Zerlegung
- Modulare Arithmetik
  - Kongruenzen
  - Restklassen
  - Lemma von Bézout
  - Chinesischer Restsatz
  - Simultane Kongruenzen
- Sätze der Zahlentheorie
  - Kleiner Satz von Fermat
  - Eulersche Phi-Funktion
  - Satz von Euler
  - Invertierbarkeit modulo n

# 2. Semester

# Programmieren 2

- Erweiterte Sprachkonzepte
  - Verschachtelte Klassen
  - Innere Klassen
  - Anonyme Klassen
  - Enumerationen
- Funktionale Programmierung
  - Lambda-Ausdrücke
  - Funktionale Interfaces
  - Methodenreferenzen
  - Höhere Funktionen
    - Funktionen als Argumente
    - Funktionen als Rückgabewerte
  - Streams
    - Map
    - Filter
    - Reduce
    - Collect
- Nebenläufigkeit
  - Thread-Grundlagen
    - Thread-Lebenszyklus
    - Thread-Erzeugung
    - Thread-Zustände
  - Thread-Management
    - Executor-Services
    - Thread-Pooling
    - Callables
    - Futures
  - Thread-Safety
    - Atomare Typen
    - Synchronized
    - Volatile
  - Thread-Kooperation
    - Wechselseitiger Ausschluss
    - Zustandssynchronisation
    - Monitor-Konzept
    - Lock
    - Conditions
  - Deadlocks
    - Erkennung
    - Vermeidung
    - Prävention
- GUI-Entwicklung
  - GUI-Prinzipien
    - Architektur
    - Komponenten
    - Layout
  - JavaFX
    - FXML
    - Scene Graph
    - Controls
  - Entwurfsmuster
    - Model-View-Controller
    - Presenter-Pattern
    - Observer-Pattern
  - Ereignisverarbeitung
    - Event-Handler
    - Event-Propagation
    - Benutzerinteraktion
- Ein-/Ausgabe
  - Filesystem
    - Dateien
    - Verzeichnisse
    - Pfade
  - Streams
    - Lesen
    - Schreiben
    - Decorator-Pattern
  - Ressourcen
    - Properties
    - Resource-Bundle
    - Zeichensätze
    - Datencodierung
- Testing
  - Testprinzipien
    - Testisolation
    - Testökonomie
    - Testabdeckung
  - Mock-Testing
    - Testdoubles
    - Stubbing
    - Mocking
  - Verifikation
    - Zustandstests
    - Verhaltensverifikation
    - Assertions

# Software-Projekt 2

- Wenden die Lerninhalte aus Programmieren 1 & 2 an.

- Projektmanagement
  - Ideenfindung und Evaluation
  - Projektplanung und Fortschrittstracking
  - Anwendung von Entwicklungswerkzeugen im Team
  - Softwareanalyse und Refactoring
  - Reflexion von Projektverlauf und Ergebnis

# Systemnahe Programmierung

- C-Grundlagen
  - Sprachelemente
  - Datentypen
  - Variablen
  - Konstanten
  - Deklarationen
- Operatoren und Ausdrücke
  - Arithmetische Operatoren
  - Logische Operatoren
  - Bitweise Operatoren
  - Zuweisungen
- Kontrollstrukturen
  - Verzweigungen
  - Schleifen
  - Switch-Case
- C-Datenstrukturen
  - Strukturen
  - Unions
  - Arrays
  - Strings
  - Funktionen
- Pointer
  - Pointerarithmetik
  - Funktionspointer
  - Doppelpointer
  - void-Pointer
- C-Speicherverwaltung
  - Stack
  - Heap
  - malloc/calloc/realloc
  - free
  - Speicherlecks
- Modulare C-Programmierung
  - Präprozessor
  - Header-Dateien
  - Compiling
  - Linking
  - MISRA C
- Unix-Grundlagen
  - Shell
  - Dateisystem-Hierarchie
  - Berechtigungen
  - Umgebungsvariablen
- Unix-Prozesse
  - fork/exec
  - Prozesszustände
  - Prozessbaum
  - Zombies/Waisen
- Unix-Threads
  - pthreads
  - Mutex
  - Semaphoren
  - Condition Variables
- Interprozesskommunikation
  - Pipes
  - Named Pipes (FIFOs)
  - Shared Memory
  - Signale
  - Sockets
- Unix-I/O
  - Dateideskriptoren
  - open/read/write/close
  - Dateisysteme
  - Systemaufrufe

# Kommunikationstechnik

- Local Area Networks
  - Ethernet
  - Bridging
- Internet Protokolle
  - IP
  - Routing
- Transport Layer
  - UDP
  - TCP
- Netzwerk Applikationen, Infrastrukturdienste und Protokolle
  - DNS
  - DHCP
  - NAT
  - HTTP etc.
- Schnittstelle zum Transport Layer (Socket-API)

# Theoretische Informatik

- Formale Sprachen
  - Alphabet
  - Wörter
  - Grammatiken
  - Chomsky-Hierarchie
- Reguläre Sprachen
  - Reguläre Ausdrücke
  - DEA
  - NEA
  - ε-NEA
  - Äquivalenz DEA/NEA
- Kontextfreie Sprachen
  - Kontextfreie Grammatiken
  - Ableitungsbäume
  - Kellerautomaten
  - Pumping-Lemma
- Berechenbarkeitsmodelle
  - Turingmaschine
  - Rekursive Sprachen
  - Church'sche These
  - Äquivalenz TM/Computer
- Programmiersprachen-Modelle
  - GOTO-Programme
  - While-Programme
  - Loop-Programme
  - Primitive Rekursion
- Entscheidbarkeit
  - Entscheidbare Probleme
  - Nicht-Entscheidbarkeit
  - Diagonalisierungssprache
  - Satz von Rice
- Semi-Entscheidbarkeit
  - Halteproblem
  - Fleissige Biber
  - Game-of-Life
  - Collatz-Zahlen
  - Reduktion
- Komplexitätstheorie
  - O-Notation
  - Omega-Notation
  - Polynomiale Funktionen
  - Exponentielle Funktionen
- Komplexitätsklassen
  - Klasse P
  - Klasse NP
  - NP-vollständig
  - NP-schwierig
  - Polynomialzeit-Reduktion

# 3. Semester

# Software-Projekt 3

- Wissen aus Software-Entwicklung 1 anwenden.
- Grössere objektorientierte Softwareapplikation entwickeln.

# Software-Entwicklung 1

- Prozessmodelle
  - Wasserfall
  - Iterativ-inkrementell
  - Agile Methoden
  - Use-Case-getrieben
  - Architekturzentriert
- Usability und UX
  - Contextual Inquiry
  - Personas
  - Szenarien
  - UI-Sketching
  - Prototyping
- Anforderungsanalyse
  - Funktionale Anforderungen
    - Use-Case-Diagramm
    - Use-Case-Spezifikation
    - Akteure
  - Nicht-funktionale Anforderungen
    - Qualitätsanforderungen
    - Randbedingungen
    - Performance
  - Domänenmodellierung
    - Domänenmodell
    - Domain Driven Design
    - Konzeptuelles Klassendiagramm
    - Ubiquitous Language
- Softwarearchitektur
  - 4+1-Sichtenmodell
  - UML-Paketdiagramm
  - UML-Deploymentdiagramm
  - Clean Architecture
    - SOLID-Prinzipien
    - Schichtenarchitektur
    - Onion Architecture
    - Dependency Inversion
- Klassendesign
  - Responsibility Driven Design
  - UML-Klassendiagramm
  - UML-Sequenzdiagramm
  - UML-Kommunikationsdiagramm
  - UML-Zustandsdiagramm
  - UML-Aktivitätsdiagramm
- Design Patterns (GoF)
  - Erzeugungsmuster
    - Factory
    - Singleton
  - Strukturmuster
    - Adapter
    - Bridge
    - Composite
    - Decorator
    - Facade
    - Proxy
  - Verhaltensmuster
    - Chain of Responsibility
    - Observer
    - State
    - Strategy
    - Visitor
- Vertiefungsthemen
  - Verteilte Systeme
  - GUI-Architekturen
  - Persistenz
  - Framework-Design

# Web-Entwicklung

- JavaScript-Grundlagen
  - Variablen
  - Datentypen
  - Arrays
  - Funktionen
  - Scoping
- JS-Ökosystem
  - JS Engines
  - ECMAScript-Versionen
  - Transpiler
  - Node.js
- Objektmodell
  - Objekte
  - Konstruktoren
  - Prototypen
  - Klassen
  - Vererbung
- Asynchrone Programmierung
  - Callbacks
  - Event Queue
  - Promises
  - Async/Await
- Server-Entwicklung
  - Node.js-Webserver
  - Modulsystem
  - JSON
  - RESTful APIs
  - Middleware
- Browser-APIs
  - Document Object Model
  - Ereignisbehandlung
  - DOM-Manipulation
  - Selektoren
- Client-Server-Kommunikation
  - Ajax
  - Fetch-API
  - HTTP-Methoden
  - Asynchrone Requests
- Zustandsmanagement
  - Cookies
  - Sessions
  - Authentisierung
  - LocalStorage
- Web-Framework
  - Single Page Applications
  - Komponentenarchitektur
  - Render-Methode
  - Komponentenzustand
  - Properties
- Komponenten-Lebenszyklus
  - Komponententypen
  - Lifecycle-Hooks
  - Ereignisbehandlung
  - Routing
  - Zustandscontainer

# Computertechnik 1

- Systemorganisation
  - Computersystemaufbau
  - Informationsdarstellung
  - Programmübersetzung
- Hardware-Architektur
  - CPU
  - Memory
  - I/O
  - Bus
- CPU-Aufbau
  - Komponenten
  - Funktionsweise
  - Instruktionssatz
  - Befehlscodierung
  - Befehlsverarbeitung
- Speicherorganisation
  - Adressierungsarten
  - Speicherzugriff
  - Memory Map
  - Endianness
  - Datentransfer
- Datentypen
  - Integer
  - Arrays
  - Pointers
  - Integer Casting
  - Typenkonvertierung
- ALU
  - Arithmetische Operationen
  - Logische Operationen
  - Statusregister
  - Flags
  - Rechnen mit ALU
- Programmablaufsteuerung
  - Funktionen
  - Unterprogramme
  - Sprungbefehle
  - Vergleichsbefehle
  - Kontrollstrukturen
- Stackframe
  - Parameterübergabe
  - Rückgabewerte
  - Lokale Variablen
  - Aufrufkonventionen
- Exceptional Control Flow
  - Hardware Interrupts
  - Interrupt Service Routine
  - Vektortabelle
  - Exceptions/Traps
- Linking
  - Linker-Funktionsweise
  - Address Resolution
  - Relocation
  - Symbol Table
  - Linker Map

# Algorithmen und Datenstrukturen

- Allgemeine Konzepte
  - Asymptotische Komplexität (O-Notation)
  - Analyse von Algorithmen (Laufzeit und Speicherplatz)
- Algorithmen-Paradigmen
  - Rekursion
  - Backtracking
  - Greedy-Algorithmen
  - Divide and Conquer
- Datenstrukturen
  - Stack und Queue
  - Liste
  - Hash-Tabelle
  - Bäume
  - Graphen
- Algorithmen
  - Suchen
  - Baum-Traversierung
  - Rotation in ausgeglichenen Suchbäumen
  - Hash-Tabellen
  - Kürzeste Wege in Graphen
  - Breiten und Tiefensuche in Graphen
  - Sortierverfahren
  - Untere Laufzeit-Schranke
- Algorithmen in Java
  - Objects/equals/hashCode
  - Comparator/Comparable
  - Collections
  - Generics
  - Iterator

- 4. Semester

# Software-Projekt 4

- Software-Entwicklungsprojekt mit etwa 7 Personen
- SCRUM

# Software-Entwicklung 2

- In dieser Vorlesung lernen die Studierenden die wichtigsten agilen Prinzipien
- Praktiken und Werte von SCRUM sowie XP kennen

# Betriebssysteme

- Analyse und Vergleich von MBR- und UEFI-Bootprozessen in Linux-Systemen
  - Funktionsweise
  - Vor- und Nachteile.
- Entwicklung eines minimalistischen Bootloaders zur Initialisierung eines Testsystems.
- Vergleich verschiedener Prozess-Scheduling-Algorithmen (z. B. Round-Robin, CFS, Priority) und deren Einfluss auf Systemleistung.
- Messung und Steuerung von Prozessressourcen mittels cgroups
  - Limits
  - Prioritäten und Isolation.
- Untersuchung der Speicherverwaltung in Linux
  - Virtueller Speicher
  - Paging
  - Swapping und Seitentabellen.
- Entwicklung eines einfachen Linux-Kernelmoduls oder Gerätetreibers unter Nutzung von DKMS.
- Vergleich von Dateisystemen und Overlay Filesystems hinsichtlich Performance
- Zuverlässigkeit und RAM-/TMP-Usage.
- Analyse und Nutzung des Logical Volume Managers (LVM)
  - Partitionen
  - Volumes und Storage-Management.
- Implementierung und Performanceanalyse virtueller Maschinen mit KVM/QEMU und Libvirt.
- Untersuchung von Systemaufrufen und Netzwerktreibern im Betriebssystem
  - Funktionsweise und Performance-Effekte.

# Computertechnik 2

- Das Modul zeigt den Ausbau eines Prozessors zu einem vollständigen Computer System.
- Vom Prozessor zum System
- Aufbau eines Microcontrollers
- Funktionsweise Systembus
- Memory Map und Adressdekodierung
- Funktion und Verwendung von Kontroll- und Statusregistern.
- Einsatz von Peripherieschaltungen
- Anschluss von IOs über GPIO
- Serieller Datentransfer
  - UART
  - SPI
  - I2C
- Timer
- Counter und ihre Anwendungen
- Analog Digital Converter (ADC)
- Hardware Abstraction
- Speicherhierarchien
- Speichertechnologien
  - Volatile
    - SRAM
    - DRAM) vs. non-volatile (ROM
    - Flash
    - EEPROM
- Anschluss von externen Speicherbausteinen
- Cache
  - Temporal and Spatial Locality
  - Auswirkungen auf die Software
- Ablaufsteuerung von Programmen
- Strukturierung eines Programmes in Module
- Software State-Machines (State-Event Model)
- Erkennen von Events
  - Polling vs. Interrupt-driven IO
- Interrupt Performance und Latency
- Hardwarenahe Programmierpraktika
- Arbeiten mit Cross-Compiler
- Linker
- Loader und Debugger

# IT-Sicherheit

    - Einführung in die Kryptographie
      - Secret and Public Key Kryptographie
      - Hashfunktionen
      - Signaturen
      - Message Authentication Codes
    - Zertifikate und Public Key Infrastructure
    - Sichere Protokolle
      - TLS
      - Quic
      - WPA2
      - etc.
    - Mechanismen zum Absichern von Netzwerken
      - Network Access Control
      - Firewall
      - VPN
      - etc.
    - Methoden zur Benutzerauthentisierung
    - Autorisierungskonzepte in Unix und Windows
    - Rechtliche Rahmenbedingungen mit Bezug auf Cybersecurity in der Schweiz

# Maschinelles Lernen & Data Mining

- In diesem Modul lernen Sie die Voraussetzungen für dessen Einsatz sowie verschiedene wichtige Algorithmen des maschinellen Lernens kennen.

- Technische Umsetzung
- Python-Code zur Datenvorverarbeitung schreiben
- Zentrale ML-Algorithmen implementieren
  - überwacht
  - unüberwacht
  - Ensemble
- End-to-End-ML-Pipelines erstellen
- Problemlösungsstrategie
- Geschäftliche Probleme als ML-Probleme formulieren
- Geeignete Algorithmen auswählen
- Entscheidungen datengestützt begründen
- Berufspraxis
- Modellleistung mit branchenüblichen Metriken validieren
- Fallstricke wie Überanpassung und Datenlecks vermeiden
- Ergebnisse technisch und nicht-technisch präsentieren
- Anwendung in der Praxis
- Einsatz in Bereichen wie Gesundheitsprognosen
- Finanzmodellierung oder Computer Vision

- Portfolio-Projekte zur Demonstration der Fähigkeiten für zukünftige Arbeitgeber
